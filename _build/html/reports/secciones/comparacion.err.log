Traceback (most recent call last):
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\site-packages\jupyter_core\utils\__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\site-packages\nbclient\client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\site-packages\jupyter_core\utils\__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\asyncio\base_events.py", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\site-packages\nbclient\client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\site-packages\nbclient\client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "C:\Users\sergi\miniconda3\envs\entorno_sc\Lib\site-packages\nbclient\client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import re, warnings

# (opcional) silenciar solo estos avisos de pandas en este bloque
with warnings.catch_warnings():
    warnings.filterwarnings("ignore", category=UserWarning, module="pandas")

date_cols = []

# HeurÃ­stica: solo columnas cuyo nombre sugiere fecha O cuyo contenido parece 'YYYY-MM-DD'
for c in df.columns:
    if df[c].dtype == "object":
        s = df[c].dropna().astype(str)
        if s.empty:
            continue
        # criterio por nombre
        name_looks_like_date = any(k in c.lower() for k in ["fecha", "date", "fec", "fech"])
        # criterio por patrÃ³n de formato ISO
        sample = s.sample(min(50, len(s)), random_state=0)
        iso_ratio = sample.str.match(r"^\d{4}-\d{2}-\d{2}$").mean()

        if name_looks_like_date or iso_ratio > 0.8:
            # Si parece ISO, fija el formato (mÃ¡s rÃ¡pido y sin warnings)
            if iso_ratio > 0.8:
                parsed = pd.to_datetime(df[c], format="%Y-%m-%d", errors="coerce")
            else:
                parsed = pd.to_datetime(df[c], errors="coerce")
            if parsed.notna().mean() > 0.8:
                df[c] = parsed
                date_cols.append(c)

# Pasar fechas a ordinal para imputaciÃ³n numÃ©rica
for c in date_cols:
    df[c] = df[c].map(lambda x: x.toordinal() if pd.notna(x) else np.nan)

print("Fechas convertidas:", date_cols)

------------------


[31m---------------------------------------------------------------------------[39m
[31mNameError[39m                                 Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 10[39m
[32m      7[39m date_cols = []
[32m      9[39m [38;5;66;03m# HeurÃ­stica: solo columnas cuyo nombre sugiere fecha O cuyo contenido parece 'YYYY-MM-DD'[39;00m
[32m---> [39m[32m10[39m [38;5;28;01mfor[39;00m c [38;5;129;01min[39;00m [43mdf[49m.columns:
[32m     11[39m     [38;5;28;01mif[39;00m df[c].dtype == [33m"[39m[33mobject[39m[33m"[39m:
[32m     12[39m         s = df[c].dropna().astype([38;5;28mstr[39m)

[31mNameError[39m: name 'df' is not defined

